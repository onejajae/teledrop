# Teledrop Project - Cursor AI Rules

## Project Overview
This is teledrop, a private file-sharing platform for self-hosted servers built with FastAPI (backend) and SvelteKit (frontend). The project follows a clean Handler-based architecture pattern with clear separation of concerns between API routes, business logic, and data access layers.

## Technology Stack
- **Backend**: Python 3.12+, FastAPI, SQLModel, Uvicorn
- **Frontend**: SvelteKit, JavaScript, TailwindCSS, Flowbite
- **Database**: SQLite with SQLModel ORM
- **Authentication**: JWT tokens, API Keys, Argon2 password hashing
- **Storage**: Local filesystem with pluggable storage interface
- **Package Management**: uv (Python), npm (Node.js)
- **Deployment**: Docker, Docker Compose

## Architecture Overview

### Handler Pattern
The application uses a Handler-based architecture where:
- **Routers** handle HTTP requests/responses and validation
- **Handlers** contain business logic and orchestrate operations
- **Models** define data structures and database queries
- **Infrastructure** provides database and storage abstractions

### Core Principles
- Single Responsibility: Each handler has one specific purpose
- Dependency Injection: All dependencies are injected through FastAPI
- Type Safety: Comprehensive type hints throughout the codebase
- Error Handling: Structured exception hierarchy with proper HTTP mapping
- Logging: Structured logging with contextual information

## Code Style and Standards

### Python (Backend)
- Follow PEP 8 style guidelines
- Use type hints for all function parameters and return values
- Use async/await for all I/O operations
- Use SQLModel for database models and queries
- Follow FastAPI best practices for dependency injection
- Use structured logging with appropriate log levels
- Handle exceptions gracefully with custom exception classes
- Use environment variables for configuration through pydantic-settings
- **Use uv for all Python dependency management and code execution**
  - Install dependencies: `uv add <package>`
  - Run Python scripts: `uv run <script>`
  - Run development server: `uv run uvicorn app.main:app --reload`
  - Sync dependencies: `uv sync`

### JavaScript (Frontend)
- Use JavaScript with JSDoc comments for type documentation when needed
- Follow Svelte/SvelteKit conventions and best practices
- Use TailwindCSS for styling with Flowbite components
- Use async/await for API calls with proper error handling
- Follow semantic versioning for dependencies
- Use ESLint and Prettier for code formatting
- Prefer composition over inheritance in Svelte components

## File & Directory Structure

This project follows a Handler-based clean architecture with clear layer separation and domain-driven organization.

### Backend Structure (Python/FastAPI)

- **Application Entry Point:** `app/main.py` - FastAPI application setup and router registration
- **Core Layer:** `app/core/` contains application-wide configuration (`config.py`), dependency injection (`dependencies.py`), and custom exceptions (`exceptions.py`)
- **API Routers:** `app/routers/api/[domain]/` format for HTTP endpoints. (e.g., `app/routers/api/drop/create.py`, `app/routers/api/auth/login.py`)
- **Business Logic Handlers:** `app/handlers/[domain]/[action].py` format for business logic implementation. (e.g., `app/handlers/drop/create.py`, `app/handlers/auth/login.py`)
- **Handler Common Functionality:** `app/handlers/mixins/` contains reusable handler capabilities. (e.g., `logging.py`, `access_control.py`, `pagination.py`, `timestamp.py`)
- **Data Models:** `app/models/[domain]/` separated by domain. Each domain contains `table.py` (DB models), `request.py` (input), `response.py` (output), `base.py` (common)
- **Infrastructure Layer:** `app/infrastructure/` contains database connections (`database/`) and storage implementations (`storage/`)
- **Utility Functions:** `app/utils/` directory contains shared utilities. (e.g., `password.py`, `token.py`, `file_utils.py`)

### Frontend Structure (SvelteKit/JavaScript)

- **Pages:** `web/src/routes/` directory following SvelteKit file-based routing conventions. Contains `+layout.svelte`, `+page.svelte`, and dynamic routes like `[slug]/`
- **UI Components:** `web/src/components/` contains all reusable components organized by functionality
  - **Common Components:** Root level components (e.g., `Header.svelte`, `Footer.svelte`, `Logo.svelte`, `Login.svelte`)
  - **Upload Components:** `web/src/components/upload/` for file upload functionality (e.g., `Form.svelte`, `Upload.svelte`, `Progress.svelte`)
  - **Preview Components:** `web/src/components/preview/` for drop viewing and management (e.g., `Preview.svelte`, `Viewer.svelte`, `FileInfo.svelte`)
  - **Error Components:** `web/src/components/preview/error/` for error handling (e.g., `Error401.svelte`, `Error403.svelte`, `Error404.svelte`)
- **Library Layer:** `web/src/lib/` contains shared functionality
  - **API Client:** `api.js` - centralized backend communication
  - **State Management:** `store.js` - global state using Svelte stores
  - **Module Exports:** `index.js` - library exports
- **Static Assets:** `web/static/static/` contains favicons, app icons, and PWA manifest files
- **Configuration:** Root level configuration files (`svelte.config.js`, `vite.config.js`, `tailwind.config.cjs`, etc.)

### Naming Conventions

- **Backend Files:** snake_case (e.g., `drop_create.py`, `user_login.py`)
- **Handler Classes:** PascalCase + Handler suffix (e.g., `DropCreateHandler`, `UserLoginHandler`)
- **Router Functions:** verb_noun format (e.g., `create_drop`, `login_user`)
- **Frontend Components:** PascalCase (e.g., `DropCard.svelte`, `LoginForm.svelte`)
- **API Functions:** camelCase (e.g., `createDrop`, `loginUser`)

### Layer Dependency Rules

```
Routers → Handlers → Models → Infrastructure
              ↓
            Utils (accessible from all layers)
            Core (accessible from all layers)
```

- Upper layers can only reference lower layers
- Minimize dependencies between modules in the same layer
- Business logic must be implemented in the Handlers layer
- Infrastructure abstractions enable pluggable implementations

## Development Guidelines

### Handler Development
- Each handler should inherit from `BaseHandler` and appropriate mixins
- Use dependency injection for all external dependencies (session, storage, settings)
- Implement proper error handling with custom exceptions
- Use structured logging with contextual information
- Follow the single responsibility principle
- Use type hints for all parameters and return values

### Handler Mixins
- `LoggingMixin`: Provides structured logging capabilities with configurable log levels
- `DropAccessMixin`: Drop access control and permission logic
- `PaginationMixin`: Pagination logic for list endpoints with configurable page sizes

### Python Development with uv
- Use `uv` as the primary package manager for Python dependencies
- Always use `uv run` prefix when executing Python commands or scripts
- Use `uv add` to add new dependencies instead of pip install
- Use `uv remove` to remove dependencies
- Keep `uv.lock` file committed to version control for reproducible builds
- Use `uv sync` to install dependencies from lock file in new environments
- Use `uv python install <version>` to manage Python versions if needed

### API Development
- Use dependency injection for database sessions, storage, and configuration
- Implement proper HTTP status codes (200, 201, 400, 401, 403, 404, 500)
- Use Pydantic models for request/response validation
- Implement comprehensive error handling with meaningful error messages
- Use SQLModel for database operations with proper transaction handling
- Follow RESTful API conventions for endpoint naming
- Implement proper authentication middleware using JWT tokens

### Database Operations
- Use SQLModel with proper session handling
- Implement query methods as class methods on model classes
- Use proper relationship loading (selectinload, joinedload)
- Handle transactions properly with rollback on errors
- Use database indexes for frequently queried fields

### Frontend Development
- Use SvelteKit's file-based routing system
- Implement proper loading states and error handling for API calls
- Use reactive statements ($:) appropriately for derived values
- Implement proper form validation with user-friendly error messages
- Use stores for shared state management
- Implement proper accessibility features (ARIA labels, keyboard navigation)
- Use TailwindCSS utilities and Flowbite components for consistent UI

### Security Considerations
- Never commit sensitive data (passwords, API keys, secrets) to version control
- Use environment variables for all configuration
- Implement proper input validation and sanitization
- Use HTTPS in production environments
- Implement proper CORS policies
- Use secure JWT token handling with appropriate expiration times
- Hash passwords using Argon2 algorithm
- Implement API key authentication for programmatic access

### Testing
- Write unit tests for business logic in handlers
- Implement integration tests for API endpoints
- Use pytest for Python testing with proper fixtures
- Test error conditions and edge cases
- Mock external dependencies (storage, database) in unit tests
- Implement frontend component testing where appropriate

### Performance
- Use async/await patterns consistently
- Implement proper database indexing
- Use connection pooling for database connections
- Implement file streaming for large file uploads/downloads
- Use proper caching strategies where appropriate
- Optimize bundle sizes and implement code splitting in frontend
- Use pagination for large data sets

### Documentation
- Document all API endpoints with proper OpenAPI/Swagger documentation
- Write clear commit messages following conventional commit format
- Include inline comments for complex business logic
- Keep README files updated with setup and deployment instructions
- Document environment variables and configuration options
- Document handler interfaces and expected behaviors

## Common Patterns

### Handler Implementation
```python
class ExampleHandler(BaseHandler, DropAccessMixin):
    """Example handler demonstrating the pattern"""
    
    def __init__(
        self,
        session: Session = Depends(get_session),
        storage: StorageInterface = Depends(get_storage),
        settings: Settings = Depends(get_settings)
    ):
        self.session = session
        self.storage = storage
        self.settings = settings
    
    @authenticate  # Authentication decorator when required
    async def execute(self, data: ExampleData, auth_data: AuthData | None = None) -> ExampleResult:
        """Execute the handler logic"""
        self.log_info("Starting example operation", data_id=data.id)
        
        try:
            # Business logic with integrated validation
            result = await self._process_data(data)
            
            self.log_info("Example operation completed", result_id=result.id)
            return result
            
        except Exception as e:
            self.log_error("Example operation failed", error=str(e))
            raise
```

### Error Handling
```python
# Backend
from app.core.exceptions import DropNotFoundError, ValidationError
from fastapi import HTTPException, status

try:
    result = await handler.execute(data)
    return result
except DropNotFoundError:
    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Drop not found")
except ValidationError as e:
    raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
```

```javascript
// Frontend
try {
    const response = await api.getDrop(dropKey);
    return response.data;
} catch (error) {
    if (error.response?.status === 404) {
        throw new Error('Drop not found');
    }
    throw new Error('Failed to fetch drop');
}
```

### Authentication
- Use JWT tokens for web interface authentication
- Use API keys for programmatic access
- Implement token refresh mechanism
- Store tokens securely in httpOnly cookies when possible
- Implement proper logout functionality that invalidates tokens

### Database Operations
```python
# Use SQLModel with proper session handling and relationships
@classmethod
def get_by_key(cls, session: Session, key: str, include_file: bool = True) -> Optional["Drop"]:
    statement = select(cls).where(cls.key == key)
    if include_file:
        statement = statement.options(selectinload(cls.file))
    
    result = session.exec(statement)
    return result.first()
```

### Dependency Injection
```python
# Handler with dependency injection through constructor
class DropCreateHandler(BaseHandler, DropAccessMixin):
    def __init__(
        self,
        session: Session = Depends(get_session),
        storage: StorageInterface = Depends(get_storage),
        settings: Settings = Depends(get_settings)
    ):
        self.session = session
        self.storage = storage
        self.settings = settings
```

## Docker and Deployment
- Use multi-stage Docker builds for optimization
- Include proper health checks in Docker containers
- Use environment variables for configuration in containers
- Implement proper logging for containerized applications
- Use docker-compose for local development and testing
- Entry point: `uvicorn app.main:app --host 0.0.0.0`

## Data Models

### Core Entities
- **Drop**: Main content entity with metadata and 1:1 file relationship
- **File**: Physical file storage with metadata (embedded in Drop model)
- **User**: Authentication information (currently single admin user)

### Relationships
- Drop ↔ File: One-to-one embedded relationship (every drop has exactly one file)
- Future enhancement: API key authentication system

When suggesting code changes or new features:
1. Follow the Handler pattern for business logic
2. Use appropriate mixins for common functionality
3. Ensure proper dependency injection
4. Implement comprehensive error handling
5. Follow the established naming conventions
6. Include appropriate tests and documentation
7. Consider security implications
8. Optimize for performance and maintainability
9. Use structured logging for observability
10. Maintain type safety throughout the codebase 