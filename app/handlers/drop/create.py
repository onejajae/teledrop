"""
Drop ìƒì„± Handler

ìƒˆë¡œìš´ Dropì„ íŒŒì¼ê³¼ í•¨ê»˜ ìƒì„±í•˜ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
íŠ¸ëœì­ì…˜ê³¼ ë³´ìƒ íŠ¸ëœì­ì…˜ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ë°ì´í„° ì¼ê´€ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.
"""

from typing import Optional, Dict, Any, BinaryIO
import hashlib
import uuid
from datetime import datetime

from sqlmodel import Session
from fastapi import Depends

from app.models import Drop
from app.handlers.base import BaseHandler

from app.infrastructure.storage.base import StorageInterface
from app.core.config import Settings
from app.core.exceptions import ValidationError, StorageError, DropKeyAlreadyExistsError
from app.utils.file_utils import sanitize_filename
from app.core.dependencies import get_session, get_storage, get_settings
from app.models.drop import DropCreateForm, DropRead


class DropCreateHandler(BaseHandler):
    """Drop ìƒì„± Handler - íŒŒì¼ê³¼ í•¨ê»˜ ìƒì„±"""
    
    def __init__(
        self,
        session: Session = Depends(get_session),
        storage: StorageInterface = Depends(get_storage),
        settings: Settings = Depends(get_settings)
    ):
        self.session = session
        self.storage = storage
        self.settings = settings
    
    
    async def execute(
        self,
        drop_data: DropCreateForm,
        upload_stream: BinaryIO,
    ) -> DropRead:
        """
        ìƒˆë¡œìš´ Dropì„ íŒŒì¼ê³¼ í•¨ê»˜ ìƒì„±í•©ë‹ˆë‹¤.
        
        Args:
            drop_data: ì™„ì „í•œ Drop ìƒì„± ë°ì´í„° (íŒŒì¼ ì •ë³´ í¬í•¨)
            upload_stream: ì—…ë¡œë“œí•  íŒŒì¼ ìŠ¤íŠ¸ë¦¼ (BinaryIO)
            auth_data: ì¸ì¦ ì •ë³´
            
        Returns:
            DropRead: ìƒì„±ëœ Drop ì •ë³´
        """
        self.log_info("Creating new drop with file", 
                     title=drop_data.title, 
                     filename=drop_data.filename,
                     expected_size=drop_data.file_size)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # 1ï¸âƒ£ DROP KEY ì²˜ë¦¬ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        slug = drop_data.slug
        if not slug or not slug.strip():
            # ê³ ìœ  í‚¤ ìƒì„±
            max_attempts = 10
            for _ in range(max_attempts):
                slug = str(uuid.uuid4())
                if not Drop.get_by_slug(self.session, slug):
                    break
            else:
                raise ValidationError("Failed to generate unique drop key")
        else:
            if Drop.get_by_slug(self.session, slug):
                raise DropKeyAlreadyExistsError(f"Drop key already exists: {slug}")
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # 2ï¸âƒ£ íŒŒì¼ ì²˜ë¦¬ ë° ê²€ì¦ (ê²€ì¦ í›„ ìƒì„± íŒ¨í„´)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        storage_path = str(uuid.uuid4())
        
        self.log_info("Processing file", path=storage_path)
        
        # ìŠ¤íŠ¸ë¦¬ë° ì €ì¥ 
        file_hash_obj = hashlib.sha256()
        actual_file_size = 0
        chunk_size = self.settings.CHUNK_SIZE

        try:
            # ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €ë¡œ ìë™ íŒŒì¼ ê´€ë¦¬
            async with self.storage.write_stream(storage_path) as storage_stream:
                # ì²­í¬ ë‹¨ìœ„ë¡œ ì½ì–´ì„œ ì²˜ë¦¬
                while chunk := upload_stream.read(chunk_size):
                    actual_file_size += len(chunk)
                    file_hash_obj.update(chunk)
                    await storage_stream.write(chunk)  

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ·ï¸ FILENAME ì²˜ë¦¬ (í•´ì‹œ ê¸°ë°˜) - drop_dataì—ì„œ ì¶”ì¶œ
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            file_hash = file_hash_obj.hexdigest()
            filename = drop_data.filename
            
            if not filename or not filename.strip():
                # í•´ì‹œëŠ” ì´ë¯¸ ì•ˆì „í•˜ë¯€ë¡œ sanitize ë¶ˆí•„ìš”
                safe_filename = file_hash
                self.log_info("Generated filename from hash", 
                             generated=safe_filename,
                             full_hash=file_hash)
            else:
                # ì™¸ë¶€ ì…ë ¥(ì‹ ë¢°í•  ìˆ˜ ì—†ìŒ)ë§Œ sanitize
                filename = filename.strip()
                safe_filename = sanitize_filename(filename)
                self.log_info("Using provided filename", 
                             original=filename, 
                             sanitized=safe_filename)

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # ğŸ” íŒŒì¼ í¬ê¸° ë¬´ê²°ì„± ê²€ì¦ (Content-Length vs ì‹¤ì œ í¬ê¸°)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            expected_size = drop_data.file_size
            if expected_size is not None and expected_size != actual_file_size:
                self.log_error("File size mismatch detected", 
                              expected=expected_size, 
                              actual=actual_file_size,
                              path=storage_path)
                # ìŠ¤í† ë¦¬ì§€ì—ì„œ íŒŒì¼ ì‚­ì œ (ë³´ìƒ íŠ¸ëœì­ì…˜)
                try:
                    await self.storage.delete_file(storage_path)
                except Exception as cleanup_error:
                    self.log_error("Failed to cleanup file after size mismatch", 
                                  path=storage_path, error=str(cleanup_error))
                
                raise ValidationError(
                    f"File size mismatch: expected {expected_size} bytes, "
                    f"but received {actual_file_size} bytes"
                )
            else:
                self.log_info("File size validation passed", 
                             expected=expected_size, 
                             actual=actual_file_size)

        except Exception as e:
            self.log_error("Error during file processing", 
                          path=storage_path, error=str(e))
            raise
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # 3ï¸âƒ£ DATABASE íŠ¸ëœì­ì…˜ - Drop ìƒì„± (ëª¨ë¸ ë©”ì„œë“œ í™œìš©)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.log_info("File processing completed successfully, creating Drop entity")
        
        try:
            # Drop ìƒì„± ë°ì´í„° ì¤€ë¹„
            create_data = {
                "title": drop_data.title,
                "description": drop_data.description,
                "password": drop_data.password,
                "is_private": drop_data.is_private,
                "is_favorite": drop_data.is_favorite,
                "updated_time": None,
                # íŒŒì¼ ì •ë³´ (í†µí•©ëœ ëª¨ë¸)
                "file_name": safe_filename,
                "file_size": actual_file_size,
                "file_type": drop_data.content_type,
                "file_hash": file_hash,
                "storage_type": self.storage.storage_type,
                "storage_path": storage_path
            }
            
            # ëª¨ë¸ì˜ create ë©”ì„œë“œ ì‚¬ìš© (ë‚´ë¶€ì—ì„œ commit ìˆ˜í–‰)
            drop = Drop.create(
                session=self.session,
                drop_data=create_data,
                slug=slug,
                created_time=self.get_current_timestamp()
            )
            
            self.log_info("Drop created successfully", 
                         drop_id=str(drop.id), 
                         slug=slug)
            
        except Exception as e:
            # ì˜ì¡´ì„±ì—ì„œ ìë™ ë¡¤ë°± ì²˜ë¦¬ë¨
            self.log_error("Database transaction failed", error=str(e))
            
            # ìŠ¤í† ë¦¬ì§€ì—ì„œ íŒŒì¼ ì‚­ì œ (ë³´ìƒ íŠ¸ëœì­ì…˜)
            try:
                await self.storage_service.delete_file(storage_path)
                self.log_info("Successfully cleaned up storage file", path=storage_path)
            except Exception as cleanup_error:
                self.log_error("Failed to cleanup storage file after DB failure", 
                              path=storage_path, error=str(cleanup_error))
            
            raise
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # 4ï¸âƒ£ ì„±ê³µ ì‘ë‹µ ë°˜í™˜
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        # DropRead ìŠ¤í‚¤ë§ˆë¡œ ë³€í™˜í•˜ì—¬ ë°˜í™˜ (model_validate ì‚¬ìš©)
        result = DropRead.model_validate(drop)
        
        self.log_info("Drop creation completed successfully", 
                     drop_id=str(drop.id), 
                     slug=slug,
                     file_size=actual_file_size)
        
        return result
